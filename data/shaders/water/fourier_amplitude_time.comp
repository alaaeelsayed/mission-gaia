#define M_PI 3.141592653589793238462643383279502884197169399375105820974944

// - - - - - - - - Process Fourier Amplitude over time - - - - - - //
// Credit to OREON ENGINE for guiding me: https://www.youtube.com/channel/UC9lXX-YnU_VcDT3VS85skMQ

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba32f) writeonly uniform image2D tilde_hkt_dy; // Height Displacement
layout (binding = 1, rgba32f) writeonly uniform image2D tilde_hkt_dx; // Choppy-x Displacement
layout (binding = 2, rgba32f) writeonly uniform image2D tilde_hkt_dz; // Choppy-z Displacement
layout (binding = 3, rgba32f) readonly uniform image2D tilde_h0k;
layout (binding = 4, rgba32f) readonly uniform image2D tilde_h0minusk;

uniform int L;
uniform float t;

// Complex Numbers
struct complex
{
    float real;
    float im;
};

// Complex Operations
complex mul(complex c0, complex c1)
{
    complex c;
    c.real= c0.real * c1.real - c0.im * c1.im;
    c.im = c0.real * c1.im + c0.im * c1.real;
    return c;
}

complex add(complex c0, complex c1)
{
    complex c;
    c.real= c0.real + c1.real;
    c.im = c0.im + c1.im;
    return c;
}

complex conj(complex c)
{
    return complex(c.real, -c.im);
}


void main(void)
{
    vec2 x = ivec2(gl_GlobalInvocationID.xy);
    vec2 k = vec2(2.0 * M_PI * x.x/L, 2.0 * M_PI * x.y/L);

    float magnitude = length(k);
    if (magnitude < 0.0001) 
        magnitude = 0.0001; // Prevent division by zero
    float w = sqrt(9.81 * magnitude); // Dispersion Relation

    complex tilde_h0k = complex(imageLoad(tilde_h0k, ivec2(gl_GlobalInvocationID.xy)).r, imageLoad(tilde_h0k, ivec2(gl_GlobalInvocationID.xy)).g);
    complex tilde_h0minuskconj = complex(imageLoad(tilde_h0minusk, ivec2(gl_GlobalInvocationID.xy)).r, imageLoad(tilde_h0minusk, ivec2(gl_GlobalInvocationID.xy)).g);

    float cosinusoid = cos(w*t);
    float sinusoid = sin(w*t);

    // Euler Formula
    complex exp_iwt = complex(cosinusoid, sinusoid);
    complex exp_iwt_inv = complex(cosinusoid, -sinusoid);

    // dy
    complex h_k_t_dy = add(mul(tilde_h0k, exp_iwt), mul(tilde_h0minuskconj, exp_iwt_inv));

    // dx
    complex dx = complex(0.0, -k.x/magnitude);
    complex h_k_t_dx = mul(dx, h_k_t_dy);

    // dz
    complex dy = complex(0.0, -k.y/magnitude);
    complex h_k_t_dz = mul(dy, h_k_t_dy);

    imageStore(tilde_hkt_dy, ivec2(gl_GlobalInvocationID.xy), vec4(h_k_t_dy.real, h_k_t_dy.im, 0, 1));
    imageStore(tilde_hkt_dx, ivec2(gl_GlobalInvocationID.xy), vec4(h_k_t_dx.real, h_k_t_dx.im, 0, 1));
    imageStore(tilde_hkt_dz, ivec2(gl_GlobalInvocationID.xy), vec4(h_k_t_dz.real, h_k_t_dz.im, 0, 1));
}