#define M_PI 3.141592653589793238462643383279502884197169399375105820974944

// - - - - - - - - Pre-process Fourier Amplitude textures  - - - - - - //
// Credit to OREON ENGINE for guiding me: https://www.youtube.com/channel/UC9lXX-YnU_VcDT3VS85skMQ

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba32f) writeonly uniform image2D tilde_h0k;
layout (binding = 1, rgba32f) writeonly uniform image2D tilde_h0minusk;

// Noise textures for generating random Gaussian numbers
uniform sampler2D noise_r0;
uniform sampler2D noise_i0;
uniform sampler2D noise_r1;
uniform sampler2D noise_i1;

// Phillips Spectrum Calculation (Effect of wind on water surface)
uniform int N; // FFT Frequency Resolution
uniform int L; // Horizontal Dimension of Ocean
uniform float A; // Amplitude 
uniform vec3 w; // Wind Direction
uniform float windspeed;
uniform float suppression;

const float g = 9.81; // Gravity


// Box-Muller-Method
vec4 randGauss()
{
    vec2 texCoord = vec2(gl_GlobalInvocationID.xy)/float(N);

    float noise00 = clamp(texture(noise_r0, texCoord).r, 0.001, 1.0);
    float noise01 = clamp(texture(noise_i0, texCoord).r, 0.001, 1.0);
    float noise02 = clamp(texture(noise_r1, texCoord).r, 0.001, 1.0);
    float noise03 = clamp(texture(noise_i1, texCoord).r, 0.001, 1.0);

    float u0 = 2.0*M_PI*noise00;
    float v0 = sqrt(-2.0 * log(noise01));
    float u1 = 2.0*M_PI*noise02;
    float v1 = sqrt(-2.0 * log(noise03));

    vec4 rnd = vec4(v0 * cos(u0), v0 * sin(u0), v1 * cos(u1), v1 * sin(u1));

    return rnd;
}

float suppression_factor(float k_mag_sqr)
{
    return exp(-k_mag_sqr * suppression * suppression);
}

float philips_power_spectrum(vec2 k, float k_mag, float k_mag_sqr, float L_philips, float suppression)
{
    return (A * (exp(-1.0 / (k_mag_sqr * L_philips * L_philips))) * pow(dot(normalize(k), w.xy), 2.0) * suppression) / (k_mag_sqr * k_mag_sqr);
}

void main()
{
    vec2  x         = vec2(gl_GlobalInvocationID.xy) - float(N) / 2.0;
    vec2  k         = vec2((2.0 * M_PI * float(x.x)) / float(L), (2.0 * M_PI * float(x.y)) / float(L));
    float L_philips = (windspeed * windspeed) / g;
    float k_mag     = length(k);

    if (k_mag < 0.00001)
        k_mag = 0.00001;

    float k_mag_sqr   = k_mag * k_mag;
    float suppression = suppression_factor(k_mag_sqr);

    float h0k      = clamp(sqrt(philips_power_spectrum(k, k_mag, k_mag_sqr, L_philips, suppression)) / sqrt(2.0), -4000.0, 4000.0);
    float h0minusk = clamp(sqrt(philips_power_spectrum(-k, k_mag, k_mag_sqr, L_philips, suppression)) / sqrt(2.0), -4000.0, 4000.0);

    vec4 rnd = randGauss();

    imageStore(tilde_h0k, ivec2(gl_GlobalInvocationID.xy), vec4(rnd.xy * h0k, 0.0, 1.0));
    imageStore(tilde_h0minusk, ivec2(gl_GlobalInvocationID.xy), vec4(rnd.zw * h0minusk, 0.0, 1.0));
}